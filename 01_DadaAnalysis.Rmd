---
title: "Myco phosphoproteomics data normalisation"
author: "Marie Locard-Paulet"
date: '`r date()`'
output: html_document
---


```{r packages, echo = F, message=FALSE}
require(ggplot2)
require(reshape2)
require(corrplot)
require(knitr)
require(gplots)
require(ggrepel)

knitr::opts_chunk$set(echo = F, warning = F)
source("RScripts/Functions/pdfMLP.R")
```

This study is the analysis of the three following *Mycobacterium smegmatis* samples:

* **L**: wild type transfected with the empty vector.
* **P**: with over-expressed PknB.
* **K**: with over-expressed mutated PknB-K40M (inactive).

Alexandre Stella and Hung Le prepared 1 mg of digested peptides (Urea lysis followed by in solution digestion) and subjected 500ug to TiO2 enrichment. The samples prior and after phospho-enrichment were injected onto the Q-Exactive Plus in technical duplicate. We work with 3 biological replicates (independent transfections). 

# Proteome

## Data set inspection

The raw files of the proteomic data set are in `RAW/Proteome_MQ041217/`. We work with the Max Quant table `proteinGroups.txt`.

```{r}
tab <- read.table("RAW/Proteome_MQ151217_IBAQ/proteinGroups_151217_IBAQ.txt", sep = "\t", header = T, stringsAsFactors = F, quote = "")
```

I remove the "REV_" and "CON_", and I keep only the proteins identified/quantified with a minimum of 2 unique peptides.

```{r}
tab <- tab[!grepl("REV_", tab$Protein.IDs) & !grepl("CON_", tab$Protein.IDs),]
tab <- tab[tab$Unique.peptides>=2,]
```

**There are `r nrow(tab)` proteins identified in the study.**

```{r}
par(mar = c(3,3,3,1))
hist(tab$Unique.peptides, col = "darkblue", breaks = 200, main = "Unique peptides per protein")
```

## Retrieve the gene names in Uniprot to correct the trimmed "Fasta header" values

I export the protein IDs for manual retrieving using `https://www.uniprot.org/uploadlists/` (20180117).

```{r}
write.table(tab$Protein.IDs, "OutputTables/ProteinIDs.txt", row.names = F)
```

```{r}
Uniprot <- read.table("RAW/MappingTableProtUniprot_20180117.txt", sep = "\t", header = T)
```

We searched the data with 2 proteome annotations from Uniprot (strain ATCC 700084 / mc(2)155 Uniprot IDs UP000000757 and UP000006158 with 6602 and 6585 entries, respectively). I choose a unique ID to be able to match the proteomic to the phospho-proteomic data later on.

```{r}
proteomes <- read.table("RAW/uniprotsmeg_20190124.tab", sep = "\t", header = T, quote = "", stringsAsFactors = F)

vectab <- tab$Protein.IDs
ltab <- sapply(vectab, strsplit, ";")

vecprot <- vector(length = length(ltab))
for (i in seq_along(ltab)) {
  val <- vectab[[i]]
  val <- sapply(val, strsplit, ";")[[1]]
  if (!is.na(val)) {
    if (length(val)>1) {
      vec <- val
      vec <- as.character(proteomes$Proteomes[match(vec, proteomes$Entry)])
      vec <- unlist(strsplit(vec, ", "))
      vecprot[i] <- paste(sort(unique(vec), decreasing = F), collapse = ", ")
    } else {
      val <- as.character(proteomes$Proteomes[proteomes$Entry==val])
    if (length(val)>0){
      vecprot[i] <- val
      }
    } 
  }
}

tab$Proteome <- vecprot
tab$Proteome <- gsub("me, UP", "me; UP", tab$Proteome)
tab$Proteome <- gsub(", UP", "UP", tab$Proteome)

# Gene names:
vecgene <- vector(length = length(ltab))
for (i in seq_along(ltab)) {
  val <- vectab[[i]]
  val <- sapply(val, strsplit, ";")[[1]]
  if (!is.na(val)) {
    if (length(val)>1) {
      vec <- val
      vec <- as.character(Uniprot$To[match(val, Uniprot$From)])
      vecgene[i] <- paste(sort(unique(vec), decreasing = F), collapse = "; ")
    } else {
      val0 <- as.character(proteomes$Proteomes[proteomes$Entry==val])
    if (length(val)>0){
      vecgene[i] <- as.character(Uniprot$To[match(val, Uniprot$From)])
      }
    } 
  }
}

tab$Gene <- vecgene
```

The new column "Proteome" contains the information of from which proteome comes the ID.
The "FALSE" are the "Pknbtub" sequences that we added and a "Biognosys7".

`r kable(data.frame(table(tab$Proteome)))`

To simplify the table, I keep only one gene name if possible. I decide to first keep the gene name. If this is not available, I keep the"MSMEG" ID, if there is none I keep the "MSMEI".

I manually check that there is no ID ambiguity in the protein names attribution.

```{r}
vec <- tab$Gene
lvec <- sapply(vec, strsplit, ";")
lvec1 <- lapply(lvec, function(x) {
  x[!grepl("MSME", x)]
})
lvec2 <- lapply(lvec, function(x) {
  x[grepl("MSMEG", x)]
})
lvec3 <- lapply(lvec, function(x) {
  x[grepl("MSMEI", x)]
})

for (i in 1:length(lvec)) {
  val1 <- lvec1[[i]]
  val2 <- lvec2[[i]]
  val3 <- lvec3[[i]]
  if (length(val1)>0) {
    vec[i] <- val1
  } else if (length(val2)>0) {
    vec[i] <- val2
  } else if (length(val3)>0) {
    vec[i] <- val3
  } else {
    vec[i] <- NA
  }
}


vec[is.na(vec)] <- tab$Protein.IDs[is.na(vec)] # Add the annotation for the mutant protein that is not in Uniprot

# Check names of proteins of interest:
IntProt <- read.table("OutputTables/ProteinsOfInterest3.txt", sep = "\t", header = T)
vec2 <- as.character(IntProt$Entry.name[match(vec, as.character(IntProt$mc.155))])
vec[(grepl("MSMEG", vec) | grepl("MSMEI", vec)) & !is.na(vec2)] <- vec2[(grepl("MSMEG", vec) | grepl("MSMEI", vec)) & !is.na(vec2)]

tab$GeneID2 <- vec
```

## Normalisation

I use the LFQ values for the quantification.

In the following boxplot:

* the red points are the quan values for PknB of smegmatis.
* the blue points are the quan values for PknB of tub.
* the green points are the quan values for mutant PknB of tub.

```{r, warning=FALSE}
int <- tab[,grepl("LFQ.intensity", names(tab))]
names(int) <- gsub(".Proteome", "", names(int))
names(int) <- gsub("LFQ.intensity", "", names(int))
par(mar = c(6,3,3,1))
boxplot(log10(int), las = 2, main = "Intensity values in the proteome")

# Add values PknB:
PknB <- tab[grepl("A0QNG1", tab$Protein.IDs),grepl("LFQ.intensity", names(tab))] # in smeg
PknB <- PknB[2:length(PknB)]
points(as.numeric(log10(PknB)), col = "red", pch = 16)

PknB <- tab[grepl("P9WI81", tab$Protein.IDs),grepl("LFQ.intensity", names(tab))] # in tub
PknB <- PknB[2:length(PknB)]
points(as.numeric(log10(PknB)), col = "blue", pch = 16)

PknB <- tab[grepl("mtPKNB", tab$Protein.IDs),grepl("LFQ.intensity", names(tab))] # mutant
PknB <- PknB[2:length(PknB)]
points(as.numeric(log10(PknB)), col = "forestgreen", pch = 16)
```

## Plot PknB quan values

```{r, warning=FALSE}
# Intensity measured for PknB before data normalisation:
PknB <- tab[grepl("A0QNG1", tab$Protein.IDs) | grepl("P9WI81", tab$Protein.IDs) | grepl("mtPKNB", tab$Protein.IDs),grepl("LFQ.intensity", names(tab)) | names(tab)=="Protein.IDs"]
names(PknB) <- gsub(".Proteome", "", names(PknB))
names(PknB) <- gsub("LFQ.intensity", "", names(PknB))
PknB <- (melt(PknB))
PknB$Protein.IDs[PknB$Protein.IDs=="A0QNG1"] <- "PknB smeg"
PknB$Protein.IDs[PknB$Protein.IDs=="P9WI81"] <- "PknB tub"
PknB$Protein.IDs[PknB$Protein.IDs=="mtPKNB"] <- "PknB-K40M tub"

PknB$Protein.IDs <- factor(as.character(PknB$Protein.IDs), levels = sort(unique(as.character(PknB$Protein.IDs)))[c(2,3,1)])

ggplot(PknB, aes(x = variable, y = value, fill = Protein.IDs)) + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "PknB across samples", subtitle = "Raw FQ") + facet_wrap(~Protein.IDs, scales = "free_y") + scale_fill_brewer(palette = "Set1")
```

```{r, warning=FALSE}
PknB <- tab[grepl("A0QNG1", tab$Protein.IDs) | grepl("P9WI81", tab$Protein.IDs) | grepl("mtPKNB", tab$Protein.IDs),grepl("LFQ.intensity", names(tab)) | names(tab)=="Protein.IDs"]
names(PknB) <- gsub(".Proteome", "", names(PknB))
names(PknB) <- gsub("LFQ.intensity", "", names(PknB))

gtab <- melt(PknB)
gtab$Conditions <- sapply(as.character(gtab$variable), function(x) {
  strsplit(x, "[123]")[[1]][1]
})

gtab$Replicates <- sapply(as.character(gtab$variable), function(x) {
  strsplit(x, "[KLP]")[[1]][2]
})
gtab$Replicates <- sapply(as.character(gtab$Replicates), function(x) {
  strsplit(x, "_")[[1]][1]
})

gtab$Protein.IDs[gtab$Protein.IDs=="A0QNG1"] <- "PknB smeg"
gtab$Protein.IDs[gtab$Protein.IDs=="P9WI81"] <- "PknB tub"
gtab$Protein.IDs[gtab$Protein.IDs=="mtPKNB"] <- "PknB-K40M tub"

gtab$Protein.IDs <- factor(as.character(gtab$Protein.IDs), levels = sort(unique(as.character(gtab$Protein.IDs)))[c(2,3,1)])

ggplot(gtab, aes(x = Conditions, y = log2(value))) + geom_boxplot() + geom_point(aes(col = Replicates)) + theme_bw() + scale_colour_brewer(palette = "Set1") + labs(title = "LFQ of PknB (median normalisation)") + ylab("log2(MS int.)") + xlab("")+ facet_wrap(~Protein.IDs)
```

## Multivariate analysis

Reproducibility of the MS runs:

```{r, warning=FALSE}
#pairs(log10(lfq), pch = ".")
intnorm <- log2(int)
intnorm[intnorm==-Inf] <- NA
M <- cor(intnorm[complete.cases(intnorm),])

colcorr <- colorRampPalette(c("white", "blue", "darkblue", "black"), bias = 0.08)
corrplot(M, method = "color", order = "hclust", tl.cex = 0.6, tl.col = "black", mar = c(1,1,1,1), col = colcorr(600), cl.lim = c(0,1))
names(intnorm) <- paste0(names(intnorm), "_Log2NormInt")

tab <- cbind(tab, log2(intnorm))
# write.table(tab, "OutputTables/NormIntProt_20180109.txt", row.names = F, sep = "\t")
```

I save the protein table as `OutputTables/NormIntProt_20180109.txt`. 

## Statistical analysis

Calculate the mean of the technical repeats:

```{r}
keep <- intnorm
intmean <- matrix(ncol = ncol(intnorm)/2, nrow=nrow(intnorm))
colnames(intmean) <- unique(gsub("_R[12]", "", colnames(intnorm)))
rownames(intmean) <- rownames(intnorm)
for (i in 1:ncol(intmean)) {
  el <- colnames(intmean)[i]
  mat <- intnorm[,grepl(el, gsub("_R[12]", "", colnames(intnorm)))]
  vec <- rowMeans(mat, na.rm = T)
  intmean[,i] <- vec
}

gtab <- melt(intmean)
ggplot(gtab, aes(x = Var2, y = value)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Proteome log2-transformed intensities") 

M <- cor(intmean[complete.cases(intmean),])
corrplot(M, method = "color", order = "hclust", tl.cex = 0.6, tl.col = "black", mar = c(2,1,1,1), col = colcorr(600))
title("Mean of technical repeats")

colnames(intmean) <- gsub("Log2NormInt", "MeanTech", colnames(intmean))
tab <- cbind(tab, intmean)
```


## Figure PknB levels in the different samples

Verification that the mutation is as expected:
I plot the mean signal of the peptides containing the mutation (sequence "") that are detected with MSMS.
```{r, warning=FALSE}
# Intensity measured for PknB before data normalisation:
PknB <- tab[grepl("A0QNG1", tab$Protein.IDs) | grepl("P9WI81", tab$Protein.IDs) | grepl("mtPKNB", tab$Protein.IDs),grepl("MeanTech", names(tab)) | names(tab)=="Protein.IDs"]
# Count the number of MSMS per condition:
PknBMSMS <- tab[grepl("A0QNG1", tab$Protein.IDs) | grepl("P9WI81", tab$Protein.IDs) | grepl("mtPKNB", tab$Protein.IDs),grepl("MS.MS.count", names(tab)) | names(tab)=="Protein.IDs"]
temp <- melt(PknBMSMS)
temp$variable <- gsub(".Proteome_R[123]", "", temp$variable)
temp <- dcast(temp, Protein.IDs~variable, sum)
temp <- temp[, names(temp) != "MS.MS.count"]
names(temp) <- gsub("MS.MS.count.", "", names(temp), fixed = T)
names(PknB) <- gsub(".", "", names(PknB), fixed = T)
names(PknB) <- gsub("_MeanTech", "", names(PknB))
for (i in 2:ncol(PknB)) {
  val <- names(PknB)[i]
  PknB[,i][temp[,val]==0] <- NA
}

PknB <- (melt(PknB))
PknB$ProteinIDs[PknB$ProteinIDs=="A0QNG1"] <- "PknB smeg"
PknB$ProteinIDs[PknB$ProteinIDs=="P9WI81"] <- "PknB tub"
PknB$ProteinIDs[PknB$ProteinIDs=="mtPKNB"] <- "PknB-K40M tub"
PknB$ProteinIDs <- factor(as.character(PknB$ProteinIDs), levels = c("PknB smeg", "PknB tub", "PknB-K40M tub"))
PknB$variable <- factor(as.character(PknB$variable), levels = c("L1", "L2", "L3", "P1", "P2", "P3", "K1", "K2", "K3"))
PknB$group <- substr(as.character(PknB$variable), 1, 1)
PknB$group <- factor(as.character(PknB$group), levels = c("L", "P", "K"))

g1 <- ggplot(PknB, aes(x = variable, y = value)) + geom_bar(stat = "identity", position = "dodge")  + labs(title = "Normalised log2-transformed LFQ when MSMS") + facet_wrap(~ProteinIDs, scales = "free_y")  + theme_light() + ylab("Log2(MS signal)") + xlab("")


g2 <- ggplot(PknB, aes(x = group, y = value, col = ProteinIDs)) + geom_point(size = 2, alpha =0.8) + labs(title = "Normalised log2-transformed LFQ when MSMS")  + scale_colour_manual(values = c("orangered2", "skyblue3", "mediumseagreen")) + ylim(10,36) + facet_wrap(~ProteinIDs) + theme_light() + ylab("Log2(MS signal)") + xlab("") 

print(g1)
print(g2)

pdfMLPManual(list(g1, g2), "Figures/PknBControl.pdf", 7, 6)
```



```{r, warning=FALSE, eval=F}
PknB <- tab[grepl("A0QNG1", tab$Protein.IDs) | grepl("P9WI81", tab$Protein.IDs) | grepl("mtPKNB", tab$Protein.IDs),grepl("LFQ.intensity", names(tab)) | names(tab)=="Protein.IDs"]
names(PknB) <- gsub(".Proteome", "", names(PknB))
names(PknB) <- gsub("LFQ.intensity", "", names(PknB))

gtab <- melt(PknB)
gtab$Conditions <- sapply(as.character(gtab$variable), function(x) {
  strsplit(x, "[123]")[[1]][1]
})

gtab$Replicates <- sapply(as.character(gtab$variable), function(x) {
  strsplit(x, "[KLP]")[[1]][2]
})
gtab$Replicates <- sapply(as.character(gtab$Replicates), function(x) {
  strsplit(x, "_")[[1]][1]
})

gtab$Protein.IDs[gtab$Protein.IDs=="A0QNG1"] <- "PknB smeg"
gtab$Protein.IDs[gtab$Protein.IDs=="P9WI81"] <- "PknB tub"
gtab$Protein.IDs[gtab$Protein.IDs=="mtPKNB"] <- "PknB-K40M tub"

gtab$Protein.IDs <- factor(as.character(gtab$Protein.IDs), levels = sort(unique(as.character(gtab$Protein.IDs)))[c(2,3,1)])

ggplot(gtab, aes(x = Conditions, y = log2(value))) + geom_boxplot() + geom_point(aes(col = Replicates)) + theme_bw() + scale_colour_brewer(palette = "Set1") + labs(title = "LFQ of PknB (median normalisation)") + ylab("log2(MS int.)") + xlab("")+ facet_wrap(~Protein.IDs)
```


## Replacement of missing values

I replace with 1% quantile from each condition

```{r}
normval <- sapply(1:ncol(intmean), function(x) {
  quantile(intmean[,x], probs = 0.01, na.rm = T)
})
```

I replace missing values when there is one or no value detected across the 3 experiments in one condition (conditions being L, K, P).

```{r}
temp <- intmean
colnames(temp) <- gsub("[123]_MeanTech", "", colnames(temp))
colnames(temp) <- gsub(".", "", colnames(temp), fixed = T)
for (el in unique(colnames(temp))) {
  mattemp <- temp[,colnames(temp)==el]
  mattemp[!is.na(mattemp)] <- 1
  for (i in 1:nrow(mattemp)) {
   if (rowSums(mattemp, na.rm = T)[i]<=1) {
     mattemp[i,][is.na(mattemp[i,])] <- 0
   } 
  }
  for (i in 1:nrow(temp)) {
   temp[i,colnames(temp)==el][mattemp[i,]==0] <- normval[colnames(temp)==el][mattemp[i,]==0]
  }
}

gtab <- melt(intmean)
ggplot(gtab, aes(x = Var2, y = value)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Proteome log2-transformed intensities before stat.") 

colnames(temp) <- colnames(intmean)
intmean <- temp
gtab <- melt(intmean)
ggplot(gtab, aes(x = Var2, y = value)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Proteome log2-transformed intensities before stat.") 
```


I perform a Welch two-sided t-test followed by a BH correction of the pvalue:

```{r statProt}
conditions <- c(".K", ".L", ".P")

source("RScripts/Functions/MakeCompMatrix.R")
combinaisons <- MakeCompMatrix(conditions)
intnorm <- intmean

lFC <- list()
lpval <- list()
lpBH <- list()
for (j in 1:nrow(combinaisons)) {
  c <- as.character(unlist(combinaisons[j,]))
  pval <- rep(NA, nrow(intnorm)) ; FC <- rep(NA, nrow(intnorm))
  mat11 <- intnorm[,substr(colnames(intnorm), 1, 2) == c[1]]
  mat12 <- intnorm[,substr(colnames(intnorm), 1, 2) == c[2]]
  for (i in c(1:nrow(intnorm))) {
    if (length(mat11[i,][!is.na(mat11[i,])]) >= 2 & length(mat12[i,][!is.na(mat12[i,])]) >= 2) {
      FC[i] <- mean(as.numeric(mat11[i,]), na.rm = T) - mean(as.numeric(mat12[i,]), na.rm = T)
      pval[i] <- t.test(as.numeric(mat11[i,]), as.numeric(mat12[i,]), na.rm = T, var.equal = F)$p.value
    }
  }
  
   pBH <- rep(NA, length(pval))
   pBH[abs(FC)>=1] <- p.adjust(pval[abs(FC)>=1], method = "BH")

  
  lFC[[j]] <- FC
  lpval[[j]] <- pval
  lpBH[[j]] <- pBH
}

combinaisons[,1] <- as.character(combinaisons[,1])
combinaisons[,2] <- as.character(combinaisons[,2])
names(lFC) <- sapply(1:nrow(combinaisons), function(x) {
  paste(as.character(combinaisons[x,]), collapse = "_Vs_")
})
names(lpval) <- sapply(1:nrow(combinaisons), function(x) {
  paste(as.character(combinaisons[x,]), collapse = "_Vs_")
})
names(lpBH) <- sapply(1:nrow(combinaisons), function(x) {
  paste(as.character(combinaisons[x,]), collapse = "_Vs_")
})

par(mfrow = c(3,2), mar = c(4,4,3,1))
for (i in seq_along(lFC)) {
  hist(lFC[[i]], col = "darkblue", main = paste0("FC ", names(lFC)[i]))
  hist(lpval[[i]], col = "darkred", main = paste0("pValues ", names(lFC)[i]))
}

source("RScripts/Functions/CBindList.R")
tabFC <- CBindList(lFC)
colnames(tabFC) <- paste0(names(lFC), "_FC")
tabpval <- CBindList(lpval)
colnames(tabpval) <- paste0(names(lpval), "_pval")
tabpBH <- CBindList(lpBH)
colnames(tabpBH) <- paste0(names(lpBH), "_pBH")

tab <- cbind(tab, tabFC, tabpval, tabpBH)

tab$Significant_KVsP <- abs(tab$.K_Vs_.P_FC)>=1 & tab$.K_Vs_.P_pBH<=0.05  & !is.na(tab$.K_Vs_.P_pBH)
tab$Significant_KVsL <- abs(tab$.K_Vs_.L_FC)>=1 & tab$.K_Vs_.L_pBH<=0.05  & !is.na(tab$.K_Vs_.L_pBH)
tab$Significant_LVsP <- abs(tab$.L_Vs_.P_FC)>=1 & tab$.L_Vs_.P_pBH<=0.05  & !is.na(tab$.L_Vs_.P_pBH)
# write.table(tab, "OutputTables/NormIntProt_20180109.txt", row.names = F, sep = "\t")
```

## Volcano plots

```{r, warning=FALSE}
par(mfrow= c(1,1))
venn(list("LVsP" = tab$Protein.IDs[tab$Significant_LVsP & !is.na(tab$Significant_LVsP)], "KVsP" = tab$Protein.IDs[tab$Significant_KVsP & !is.na(tab$Significant_KVsL)]))
title("Regulated proteins")

gtab <- tab[,grepl("_FC", names(tab)) | grepl("_pval", names(tab)) | grepl("Significant", names(tab)) | names(tab) == "GeneID2"]
gtab$label <- gtab$GeneID2
gtab$label[gtab$Significant_KVsP != TRUE] <- NA

g1 <- ggplot(gtab, aes(x = -.K_Vs_.P_FC, y = -log10(.K_Vs_.P_pval), col = Significant_KVsP, label = label)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red")) + geom_vline(xintercept = 0) + geom_text_repel(size = 2.3) + labs(title = "Proteins regulated between PknB WT and K40M")
print(g1)

gtab$label <- gtab$GeneID2
gtab$label[gtab$Significant_KVsL != TRUE] <- NA
g2 <- ggplot(gtab, aes(x = -.K_Vs_.L_FC, y = -log10(.K_Vs_.L_pval), col = Significant_KVsL, label = label)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red")) + geom_vline(xintercept = 0) + geom_text_repel(size = 2.3) + labs(title = "Proteins regulated between PknB-K40M and empty vector")
print(g2)

gtab$label <- gtab$Gene
gtab$label[gtab$Significant_LVsP != TRUE] <- NA
g3 <- ggplot(gtab, aes(x = -.L_Vs_.P_FC, y = -log10(.L_Vs_.P_pval), col = Significant_LVsP, label = label)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red")) + geom_vline(xintercept = 0) + geom_text_repel(size = 2.3) + labs(title = "Proteins regulated between empty vector and PknB")
print(g3)

source("RScripts/Functions/pdfMLP.R")

pdfMLP(list(g1, g2, g3), "Figures/VolcanoProt.pdf", "landscape")

gtab$label <- gtab$Gene
gtab$label[!(gtab$Significant_KVsP == TRUE | gtab$Significant_LVsP == TRUE)] <- NA
g1 <- ggplot(gtab, aes(x = -.L_Vs_.P_FC, y = -.K_Vs_.P_FC, col = !is.na(label), label = label)) + geom_vline(xintercept = 0, col = "grey60") + geom_hline(yintercept = 0, col = "grey60") + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red"))  + geom_text_repel(size = 2.3) + labs(title = "Proteomic regulations upon PknB overexpression") + xlab("log2(PknB / control)") + ylab("log2(PknB / PknB-K40M)")
print(g1)

pdfMLP(plot = g1, "Figures/ProteomicsFC.pdf", "landscape")
```



```{r}
write.table(tab, "OutputTables/NormIntProt_20180110.txt", row.names = F, sep = "\t")
```


## Normalisation factor for phosphoproteomics data set
I calculate a normalisation factor for each protein in each run.
The vertical red line indicates the median intensity of PknB.

```{r, warning=FALSE}
intnorm <- keep
medprot <- sapply(1:nrow(intnorm), function(x) {
  median(as.numeric(intnorm[x,]), na.rm = T)
})
rownames(intnorm) <- tab$Protein.IDs

hist(medprot, col = "darkblue", main = "Median intensity per protein")
val <- medprot[rownames(intnorm)=="A0QNG1"]
abline(v = val, col =  "red", lwd = 2)

matnorm <- intnorm
for (i in 1:nrow(intnorm)) {
  matnorm[i,] <- intnorm[i,]/medprot[i]
}

hist(as.matrix(matnorm), col = "darkblue", main = "Normalisation factors")
rownames(matnorm) <- tab$Protein.IDs

save(matnorm, file = "RData/NormalisationMatrixFromProteome.RData")
```

********************************************************************************
# Phospho-enriched samples


## Quality check


I remove the `CON_` and `REV_`.

```{r}
tab <- read.table("RAW/Phospho_MQ110118_PhosSTY/Phospho (STY)Sites.txt", sep = "\t", header = T, stringsAsFactors = F, quote = "")
hist(tab$Localization.prob, col = "darkblue")
hist(tab$PEP, col = "darkred")
tab <- tab[!grepl("REV_", tab$Proteins) & !grepl("CON_", tab$Proteins),]
```

There are `r nrow(tab)` phosphorylation sites identified in the study (from `r length(unique(tab$Protein))` proteins).


I keep only the sites with 75% localisation probability (above or equal):
```{r}
tab <- tab[tab$Localization.prob>=0.75,]
hist(tab$Localization.prob, col = "darkblue")
tab <- tab[!grepl("REV_", tab$Protein),]
```

There are `r nrow(tab)` phosphorylation sites identified in the study (from `r length(unique(tab$Protein))` proteins).

## Retrieve the gene names in Uniprot to correct the trimmed "Fasta header" values

I export the protein IDs for manual retrieving using `https://www.uniprot.org/uploadlists/` (20180117).

```{r}
write.table(tab$Proteins, "OutputTables/ProteinIDsPhospho.txt", row.names = F)
```

```{r}
Uniprot <- read.table("RAW/MappingTableProtUniprot_Phospho_20180118.txt", sep = "\t", header = T)
```
We searched the data with 2 proteome annotations from Uniprot (see document `ProteomesComparison`). I choose a unique ID to be able to match the proteomic to the phospho-proteomic data later on.

```{r}
proteomes <- read.table("RAW/uniprotsmeg_20190124.tab", sep = "\t", header = T, quote = "")

vectab <- tab$Proteins
ltab <- sapply(vectab, strsplit, ";")

vecprot <- vector(length = length(ltab))
for (i in seq_along(ltab)) {
  val <- vectab[[i]]
  val <- sapply(val, strsplit, ";")[[1]]
  if (!is.na(val) & length(val)>0) {
    if (length(val)>1) {
      vec <- val
      vec <- as.character(proteomes$Proteomes[match(vec, proteomes$Entry)])
      vecprot[i] <- paste(sort(unique(vec), decreasing = F), collapse = ", ")
    } else {
      val <- as.character(proteomes$Proteomes[proteomes$Entry==val])
    if (length(val)>0){
      vecprot[i] <- val
      }
    } 
  }
}

tab$Proteome <- vecprot
tab$Proteome <- gsub("me, UP", "me; UP", tab$Proteome)
tab$Proteome <- gsub(", UP", "UP", tab$Proteome)

# Gene names:
vecgene <- vector(length = length(ltab))
for (i in seq_along(ltab)) {
  val <- vectab[[i]]
  val <- sapply(val, strsplit, ";")[[1]]
  if (!is.na(val)) {
    if (length(val)>1) {
      vec <- val
      vec <- as.character(Uniprot$To[match(val, Uniprot$From)])
      vecgene[i] <- paste(sort(unique(vec), decreasing = F), collapse = "; ")
    } else {
      val0 <- as.character(proteomes$Proteomes[proteomes$Entry==val])
    if (length(val)>0){
      vecgene[i] <- as.character(Uniprot$To[match(val, Uniprot$From)])
      }
    } 
  }
}

tab$Gene <- vecgene
```


```{r, warning=F}
int <- tab[,grepl("Intensity", names(tab))]
int <- int[,2:ncol(int)]
int <- int[,grepl("___1", names(int))]
int <- int[,2:ncol(int)]

gtab <- melt(int)
ggplot(gtab, aes(x = variable, y = log10(value))) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Phosphoproteome intensities", subtitle = "Raw") + geom_point(alpha = 0.2, position = "jitter")
```

## Normalisation based on the iRTs

```{r, warning=FALSE}
IRT <- read.table("RAW/NormFactorsFromIRT_20171205.txt", header = T, sep = "\t", stringsAsFactors = F)

names(int) <- gsub("___1", "", names(int))
int[int==0] <- NA

intnorm <- int
for (i in 1:ncol(int)) {
  intnorm[,i] <- int[,i]/as.numeric(IRT[i])
}

gtab <- melt(intnorm)
ggplot(gtab, aes(x = variable, y = log10(value))) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Phosphoproteome intensities", subtitle = "After iRT normalisation") + geom_point(alpha = 0.2, position = "jitter")


M <- cor(log10(intnorm[complete.cases(int),]))

corrplot(M, method = "shade", order = "hclust", tl.cex = 0.6, tl.col = "black", mar = c(1,1,1,1), col = colcorr(600), cl.lim = c(0,1))
```

```{r}
names(intnorm) <- paste0(names(intnorm), "_Log2NormInt")
tab <- cbind(tab, log2(intnorm))

write.table(tab, "OutputTables/NormIntPhospho_20180117.txt", row.names = F, sep = "\t")
```

## Normalisation to the protein changes


Each protein is normalised with a normalisation factor calculated in the proteomics data set.

I remove the CON_ and REV_ in the phospho table.

```{r}
tab$UID <- 1:nrow(tab)
rownames(intnorm) <- tab$UID


intnorm <- intnorm[!grepl("REV_", tab$Leading.proteins) & !grepl("CON_", tab$Leading.proteins),]
tab <- tab[!grepl("REV_", tab$Leading.proteins) & !grepl("CON_", tab$Leading.proteins),]
```

**There are `r nrow(tab)` rows in the phospho table.**

```{r}
vecprot <- rownames(matnorm)
vecphos <- tab$Proteins

source("RScripts/Functions/ReOrderProteins.R")
# Reorder the protein names:
vecprot <- ReOrderProteins(vecprot)
vecphos <- ReOrderProteins(vecphos)
tab$OrderedProtNames <- vecphos
rownames(matnorm) <- vecprot

require(gplots)
venn(list("Protein IDs" = vecprot, "Phospho IDs" = vecphos))
title("Direct matching of protein data to phospho data")
```

I finely match the protein ID from the phospho data set to the proteome.

```{r}
# Create a table for matching:
matchingtable <- cbind("UID" = tab$UID, "PhosName" = vecphos, "MatchingProtName" = vecprot[match(vecphos, vecprot)])

diffphos <- setdiff(vecphos, vecprot)
diffprot <- setdiff(vecprot, vecphos)
diffprot <- diffprot[!grepl("REV_", diffprot) & !grepl("CON_", diffprot)]

for (i in 1:nrow(matchingtable)) {
  if (is.na(matchingtable[i,3])) {
    el <- matchingtable[i,2]
    vec <- strsplit(el, ";")[[1]]
    n <- 0
    for (j in seq_along(vec)) {
      if (sum(grepl(vec[j], diffprot)) > 0) {
        k <- grep(vec[j], diffprot)
        if (length(k)>1) { 
          print(paste0("Too many matches ", diffprot[k])) 
        } else {
          n <- n+1
          matchingtable[i,3] <- diffprot[k]
          #print(paste0(el, " ", diffprot[k]))
        }
      }
    }
    if (n > 1) {
      matchingtable[i,3] <- "Several protein matches"
      #print("Several Prot match")
    }
  }
}

# FOr the proteins from the phosphotable that are unique (no ambiguity), I match them to the group of proteins that contains it in the protein table.
temp <- matchingtable[is.na(matchingtable[,3]),2]
temp2 <- matchingtable[is.na(matchingtable[,3]),3]
for (i in 1:length(temp)) {
  valphos <- temp[i]
  if (!grepl(";", valphos)) {
    valprot <- vecprot[grepl(valphos, vecprot)] 
    if (length(valprot)==1) {
      temp2[i] <- valprot
      #print(valprot)
    }
  }
}
matchingtable[is.na(matchingtable[,3]),3] <- temp2

nPhosphosite <- nrow(matchingtable)
nMatched <- length(matchingtable[(!is.na(matchingtable[,3]) & matchingtable[,3] != "Several protein matches"),2])
perc <- (nMatched/nPhosphosite)*100

venn(list("Protein IDs" = matchingtable[,3], "Phospho IDs" = matchingtable[,2]))
title("Final matching of protein data to phospho data")
``` 

We match `r round(perc, 2)`% of the sites to the corresponding protein value in the proteome.

```{r, warning=FALSE}
tab$ProtMatchingName <- matchingtable[match(tab$OrderedProtNames, matchingtable[,2]),3]
matnorm2 <- matnorm
matnorm2$ProtMatchingName <- rownames(matnorm2)
colnames(matnorm2) <- gsub("Log2NormInt", "ProtNormFactor", names(matnorm2))
tab <- merge(tab, matnorm2, by = "ProtMatchingName", all = T)

intphos <- tab[,grepl("_Log2NormInt", names(tab))]
matnorm <- tab[,grepl("ProtNormFactor", names(tab))]

for (i in 1:ncol(intphos)) {
  for (j in 1:nrow(intphos)) {
    intphos[j,i] <- intphos[j,i]/matnorm[j,i]
  }
}

gtab <- melt(intphos)
g <- ggplot(gtab, aes(x = variable, y = value)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Phosphoproteome log2-transformed intensities", subtitle = "After normalisation to the proteins") + geom_point(alpha = 0.2, position = "jitter")
print(g)

pdfMLP(g, "Figures/PhosphoGlobal.pdf", "landscape")

names(intphos) <- gsub("Log2NormInt", "NormToProt", names(intphos))
tab <- cbind(tab, intphos)

par(mar = c(1,1,1,1))
M <- cor(intphos[complete.cases(intphos),])
corrplot(M, method = "shade", order = "hclust", tl.cex = 0.6, tl.col = "black", mar = c(2,1,1,1), col = colcorr(600), cl.lim = c(0,1))
```

# Calculation of the values per biological repeat

```{r, warning=FALSE}
intmean <- matrix(ncol = ncol(intphos)/2, nrow=nrow(intphos))
colnames(intmean) <- unique(gsub("_R[12]", "", colnames(intphos)))
rownames(intmean) <- rownames(intphos)
for (i in 1:ncol(intmean)) {
  el <- colnames(intmean)[i]
  mat <- intphos[,grepl(el, gsub("_R[12]", "", colnames(intphos)))]
  vec <- rowMeans(mat, na.rm = T)
  intmean[,i] <- vec
}

gtab <- melt(intmean)
g <- ggplot(gtab, aes(x = Var2, y = value)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Phosphoproteome log2-transformed intensities", subtitle = "After normalisation to the proteins") + geom_point(alpha = 0.2, position = "jitter")
print(g)

pdfMLP(g, "Figures/PhosphoMeanTech.pdf", "landscape")

M <- cor(intmean[complete.cases(intmean),])
corrplot(M, method = "shade", order = "hclust", tl.cex = 0.6, tl.col = "black", mar = c(2,1,1,1), col = colcorr(600), cl.lim = c(0,1))

pca <- prcomp(intmean[complete.cases(intmean),])
summary(pca)

gtab <- as.data.frame(pca$rotation)
gtab$Names <- rownames(gtab)

require(ggrepel)
g <- ggplot(gtab, aes(x = PC1, y = PC2, label = Names)) + geom_point() + geom_text_repel()
print(g)

pdfMLP(g, "Figures/PCAPhospho.pdf", "landscape")
```

I add the information in the output table.

```{r}
colnames(intmean) <- gsub("NormToProt", "MeanTech", colnames(intmean))
tab <- cbind(tab, intmean)

write.table(tab, "OutputTables/NormIntPhospho_20170110.txt", row.names = F, sep = "\t")
```

## Replacement of missing values

Selective replacement when there is only one or zero measurement for a site in a given condition (K, L, P).

```{r}
# When I tried replassing systematically all missing values
matNA <- intmean # 0: missing value, 1: measured value
matNA[!is.na(intmean)] <- 1
matNA[is.na(intmean)] <- 0

colnames(matNA) <- gsub("[123].500ug_MeanTech", "", colnames(matNA))
colnames(matNA) <- gsub("Intensity.", "", colnames(matNA), fixed = T)

matNARep <- matNA
#colnames(matNARep) <- colnames(intmean)
for (el in unique(colnames(matNA))) {
  mattemp <- matNA[,colnames(matNA)==el]
  for (i in 1:nrow(mattemp)) {
   if (rowSums(mattemp, na.rm = T)[i]>=2) {
     mattemp[i,][mattemp[i,]==0] <- 1
   } 
  }
  matNARep[,colnames(matNARep)==el] <- mattemp # Here it is not 1:present 0:missing value any more. It is 1: do not replace; 0: do replace. According the chosen filters.
}

```

Replacement with 1% quantile of all the conditions, to avoid a bias due to the increase in general intensity when the kinase is over-expressed.

```{r}
replacement <- quantile(intmean, probs = 0.01, na.rm = T)

intmean[matNARep==0] <- replacement

gtab <- melt(intmean)
ggplot(gtab, aes(x = Var2, y = value)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title = "Phosphoproteome log2-transformed intensities", subtitle = "After replacement of missing values") + geom_point(alpha = 0.2, position = "jitter")
```


## t-test

Welch two-sided t-test followed by BH correction of the pvalue.

```{r}
conditions <- c("Intensity.K", "Intensity.L", "Intensity.P")

combinaisons <- MakeCompMatrix(conditions)

lFC <- list()
lpval <- list()
lpBH <- list()
for (j in 1:nrow(combinaisons)) {
  c <- as.character(unlist(combinaisons[j,]))
  pval <- rep(NA, nrow(intmean)) ; FC <- rep(NA, nrow(intmean))
  mat01 <- matNA[,substr(colnames(intmean), 1, 11) == c[1]]
  mat02 <- matNA[,substr(colnames(intmean), 1, 11) == c[2]]
  mat11 <- intmean[,substr(colnames(intmean), 1, 11) == c[1]]
  mat12 <- intmean[,substr(colnames(intmean), 1, 11) == c[2]]
  
  k <- (rowSums(mat01) >= 2) | (rowSums(mat02) >= 2) # T = apply t-test, F = do not perform stat.
  for (i in c(1:nrow(intmean))[as.logical(k)]) {
    FC[i] <- mean(as.numeric(mat11[i,]), na.rm = T) - mean(as.numeric(mat12[i,]), na.rm = T)
    pval[i] <- t.test(as.numeric(mat11[i,]), as.numeric(mat12[i,]), na.rm = T, var.equal = F)$p.value
  }
  
  pBH <- rep(NA, length(pval))
  vec <- p.adjust(pval, method = "BH")
  pBH <- vec
  
  lFC[[j]] <- FC
  lpval[[j]] <- pval
  lpBH[[j]] <- pBH
}

combinaisons[,1] <- as.character(combinaisons[,1])
combinaisons[,2] <- as.character(combinaisons[,2])
names(lFC) <- sapply(1:nrow(combinaisons), function(x) {
  paste(as.character(combinaisons[x,]), collapse = "_Vs_")
})
names(lpval) <- sapply(1:nrow(combinaisons), function(x) {
  paste(as.character(combinaisons[x,]), collapse = "_Vs_")
})
names(lpBH) <- sapply(1:nrow(combinaisons), function(x) {
  paste(as.character(combinaisons[x,]), collapse = "_Vs_")
})

par(mfrow = c(3,2), mar = c(4,4,3,1))
for (i in seq_along(lFC)) {
  hist(lFC[[i]], col = "darkblue", main = paste0("FC ", names(lFC)[i]))
  hist(lpval[[i]], col = "darkred", main = paste0("pValues ", names(lFC)[i]))
}

source("RScripts/Functions/CBindList.R")
tabFC <- CBindList(lFC)
colnames(tabFC) <- paste0(names(lFC), "_FC")
tabpval <- CBindList(lpval)
colnames(tabpval) <- paste0(names(lpval), "_pval")
tabpBH <- CBindList(lpBH)
colnames(tabpBH) <- paste0(names(lpBH), "_pBH")

tab <- cbind(tab, tabFC, tabpval, tabpBH)
tab <- tab[!is.na(tab$Proteins),]
```

## Volcano plots

```{r}
tab$Significant_KVsP <- abs(tab$Intensity.K_Vs_Intensity.P_FC)>=1 & tab$Intensity.K_Vs_Intensity.P_pBH<=0.05  & !is.na(tab$Intensity.K_Vs_Intensity.P_pBH)
tab$Significant_KVsL <- abs(tab$Intensity.K_Vs_Intensity.L_FC)>=1 & tab$Intensity.K_Vs_Intensity.L_pBH<=0.05  & !is.na(tab$Intensity.K_Vs_Intensity.L_pBH)
tab$Significant_LVsP <- abs(tab$Intensity.L_Vs_Intensity.P_FC)>=1 & tab$Intensity.L_Vs_Intensity.P_pBH<=0.05  & !is.na(tab$Intensity.L_Vs_Intensity.P_pBH)

table(tab$Significant_KVsL)
table(tab$Significant_KVsP)
table(tab$Significant_LVsP)

par(mfrow= c(1,1))
venn(list("LVsP" = tab$UID[tab$Significant_LVsP & !is.na(tab$Significant_LVsP)], "KVsP" = tab$UID[tab$Significant_KVsP & !is.na(tab$Significant_KVsL)]))


gtab <- tab[,grepl("_FC", names(tab)) | grepl("_pval", names(tab)) | grepl("Significant", names(tab))]

ggplot(gtab, aes(x = -Intensity.K_Vs_Intensity.P_FC, y = -log10(Intensity.K_Vs_Intensity.P_pval), col = Significant_KVsP)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red")) + geom_vline(xintercept = 0)
```

## Create phosID

```{r}
vec <- tab$Gene
lvec <- sapply(vec, strsplit, ";")
lvec1 <- lapply(lvec, function(x) {
  x[!grepl("MSME", x)]
})
lvec2 <- lapply(lvec, function(x) {
  x[grepl("MSMEG", x)]
})
lvec3 <- lapply(lvec, function(x) {
  x[grepl("MSMEI", x)]
})
# Matching protein position:
pos <- tab$Positions.within.proteins
lpos <- sapply(pos, strsplit, ";")

lpos1 <- lapply(1:length(lvec), function(x) {
  lpos[[x]][!grepl("MSME", lvec[[x]])]
})
lpos2 <- lapply(1:length(lvec), function(x) {
  lpos[[x]][grepl("MSMEG", lvec[[x]])]
})
lpos3 <- lapply(1:length(lvec), function(x) {
  lpos[[x]][grepl("MSMEI", lvec[[x]])]
})


for (i in 1:length(lvec)) {
  val1 <- lvec1[[i]]
  val2 <- lvec2[[i]]
  val3 <- lvec3[[i]]
  if (length(val1)>0) {
    vec[i] <- val1
    postemp <- as.numeric(lpos1[[i]])
    if (length(unique(postemp))==1) {
      pos[i] <- unique(postemp)
    } else {
      pos[i] <- paste(unique(postemp), collapse="|")
    }
  } else if (length(val2)>0) {
    vec[i] <- val2
    pos[i] <- lpos2[[i]]
  } else if (length(val3)>0) {
    vec[i] <- val3
    pos[i] <- lpos3[[i]]
  } else {
    vec[i] <- NA
    pos[i] <- NA
  }
}



# Check names of proteins of interest:
#IntProt <- read.table("OutputTables/ProteinsOfInterest2.txt", sep = "\t", header = T)
vec2 <- as.character(IntProt$Entry.name[match(vec, as.character(IntProt$mc.155))])
vec[(grepl("MSMEG", vec) | grepl("MSMEI", vec)) & !is.na(vec2)] <- vec2[(grepl("MSMEG", vec) | grepl("MSMEI", vec)) & !is.na(vec2)]

tab$GeneID2 <- vec
tab$Position2 <- pos

tab$PhosID <- paste0(tab$GeneID2, "-", tab$Amino.acid, tab$Position2)
```

Volcano with sites of interest:

```{r}
gtab <- tab[,grepl("_FC", names(tab)) | grepl("_pval", names(tab)) | grepl("Significant", names(tab)) | names(tab) == "PhosID" | names(tab) == "GeneID2"]
gtab$label <- gtab$PhosID
gtab$label[!(toupper(gtab$GeneID2) %in% toupper(c(as.character(IntProt$Entry.name), "pknb", "pknbtub", "mtpknb")))] <- NA
gtab$label[!(gtab$Significant_KVsP)] <- NA

g <- ggplot(gtab, aes(x = -Intensity.K_Vs_Intensity.P_FC, y = -log10(Intensity.K_Vs_Intensity.P_pval), label = label, col = Significant_KVsP)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red")) + geom_vline(xintercept = 0) + geom_text_repel(col = "black", size = 3.5)  + labs(title = "PknB Vs PknB-K40M")
print(g)

gtab$label <- gtab$PhosID
gtab$label[!(toupper(gtab$GeneID2) %in% toupper(c(as.character(IntProt$Entry.name), "pknb", "pknbtub", "mtpknb")))] <- NA
gtab$label[!(gtab$Significant_KVsL)] <- NA

g1 <- ggplot(gtab, aes(x = -Intensity.K_Vs_Intensity.L_FC, y = -log10(Intensity.K_Vs_Intensity.L_pval), label = label, col = Significant_KVsL)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red")) + geom_vline(xintercept = 0) + geom_text_repel(col = "black", size = 3.5)  + labs(title = "Empty vector Vs PknB-K40M")
print(g1)

gtab$label <- gtab$PhosID
gtab$label[!(toupper(gtab$GeneID2) %in% toupper(c(as.character(IntProt$Entry.name), "pknb", "pknbtub", "mtpknb")))] <- NA
gtab$label[!(gtab$Significant_LVsP)] <- NA

g2 <- ggplot(gtab, aes(x = -Intensity.L_Vs_Intensity.P_FC, y = -log10(Intensity.L_Vs_Intensity.P_pval), label = label, col = Significant_LVsP)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red")) + geom_vline(xintercept = 0) + geom_text_repel(col = "black", size = 3.5)  + labs(title = "PknB Vs Empty vector")
print(g2)

pdfMLP(list(g, g1, g2), "Figures/VolcanoPhospho.pdf", "landscape")
```

```{r}
write.table(tab, "OutputTables/StatTable_20180117.txt", sep = "\t", row.names = F)
save(tab, file = "RData/Stat.RData")
```

Volcano for the paper (with the known substrates of PknB):

```{r}
# Distinction between the tub Vs smeg PknB:

tab$PhosID[tab$ProtMatchingName=="A0QNG1" & !is.na(tab$ProtMatchingName)] <- paste0("Smeg_", tab$PhosID[tab$ProtMatchingName=="A0QNG1" & !is.na(tab$ProtMatchingName)])

gtab <- tab[,grepl("_FC", names(tab)) | grepl("_pval", names(tab)) | grepl("Significant", names(tab)) | names(tab) == "PhosID" | names(tab) == "GeneID2"]
gtab$GeneID2 <- gsub(" ", "", gtab$GeneID2)
gtab$col <- gtab$Significant_KVsP
gtab$col[(toupper(gtab$GeneID2) %in% toupper(c(as.character(IntProt$Entry.name[IntProt$category == "Known markers phosphorylated (substrates of PknB)"])))) & gtab$Significant_KVsP] <- "Known"
gtab$label <- gtab$PhosID
gtab$label[!(toupper(gtab$GeneID2) %in% toupper(c(as.character(IntProt$Entry.name[IntProt$category == "Known markers phosphorylated (substrates of PknB)"]))))] <- NA
gtab$label[!(gtab$Significant_KVsP)] <- NA

g <- ggplot(gtab, aes(x = -Intensity.K_Vs_Intensity.P_FC, y = -log10(Intensity.K_Vs_Intensity.P_pval), label = label, col = col)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red", "darkorange")) + geom_vline(xintercept = 0) + geom_text_repel(col = "black", size = 3.5)  + labs(title = "PknB Vs PknB-K40M")
print(g)

gtab$col <- gtab$Significant_KVsL
gtab$col[(toupper(gtab$GeneID2) %in% toupper(c(as.character(IntProt$Entry.name[IntProt$category == "Known markers phosphorylated (substrates of PknB)"])))) & gtab$Significant_KVsL] <- "Known"
gtab$label <- gtab$PhosID
gtab$label[!(toupper(gtab$GeneID2) %in% toupper(c(as.character(IntProt$Entry.name[IntProt$category == "Known markers phosphorylated (substrates of PknB)"]))))] <- NA
gtab$label[!(gtab$Significant_KVsL)] <- NA

g1 <- ggplot(gtab, aes(x = -Intensity.K_Vs_Intensity.L_FC, y = -log10(Intensity.K_Vs_Intensity.L_pval), label = label, col = col)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red", "darkorange")) + geom_vline(xintercept = 0) + geom_text_repel(col = "black", size = 3.5)  + labs(title = "Empty vector Vs PknB-K40M")
print(g1)

gtab$col <- gtab$Significant_LVsP
gtab$col[(toupper(gtab$GeneID2) %in% toupper(c(as.character(IntProt$Entry.name[IntProt$category == "Known markers phosphorylated (substrates of PknB)"])))) & gtab$Significant_LVsP] <- "Known"
gtab$label <- gtab$PhosID
gtab$label[!(toupper(gtab$GeneID2) %in% toupper(c(as.character(IntProt$Entry.name[IntProt$category == "Known markers phosphorylated (substrates of PknB)"]))))] <- NA
gtab$label[!(gtab$Significant_LVsP)] <- NA

g2 <- ggplot(gtab, aes(x = -Intensity.L_Vs_Intensity.P_FC, y = -log10(Intensity.L_Vs_Intensity.P_pval), label = label, col = col)) + geom_point(alpha = 0.6) + theme_minimal() + scale_color_manual(values = c("black", "red", "darkorange")) + geom_vline(xintercept = 0) + geom_text_repel(col = "black", size = 3.5)  + labs(title = "PknB Vs Empty vector")
print(g2)

pdfMLPManual(list(g, g1, g2), "Figures/VolcanoPhospho_Paper.pdf", 6, 5)
```

********************************************************************************

```{r}
sessionInfo()
```